# Profilování

- detekce problémů během skutečného běhu programu, nejen po výskytu chyb
- identifikace příčin bugů v kódu (statická analýza často nestačí)
- získání informací, které testy a benchmarky neposkytují, zejména u vícevláknových aplikací
- **Monitorování nasazeného SW**: stav serveru, využití paměti, hledání memory leaků

### Profilování vs. benchmarkování

|                    | Profilování (white‑box)                 | Benchmarkování (black‑box)        |
| ------------------ | --------------------------------------- | --------------------------------- |
| **Cíl**            | Proč se program chová tak, jak se chová | Porovnání variant, měření výkonu  |
| **Zaměření**       | Spotřeba zdrojů (CPU, RAM, GC…)         | Celkový výkon a odezvu pod zátěží |
| **Potřeba zátěže** | Opakovatelná, izolovaná zátěž           | Reprezentativní pracovní zátěž    |
| **Interpretace**   | Vyžaduje detailní analýzu a kontext     | Často stačí souhrnný výsledek     |

### Požadavky na profiler

- **přesnost** – zachytit vše, co se v programu stalo
- **nízký overhead** – minimální dopad na výkon i paměť, aby byl použit i v produkci
- **přenositelnost** a **strojová zpracovatelnost** výstupů
- integrace s IDE, SDK nebo hypervisory je výhodou

### Instrumentace vs. vzorkování

**Instrumentace**
- vložení kódu před nebo během běhu (binární soubory, zdrojové texty)
- přesnější, ale může zpomalit program a zavést bezpečnostní rizika

**Vzorkování**
- periodické zachytávání stavu (PC, registry, paměť) během běhu
- neinvazivní, ale poskytuje jen aproximaci

### Druhy profilování

- **binární instrumentace** – úprava spustitelného souboru nebo bytecode, často se „sondami“, možnost úpravy běhu
- **statistické profily / samplery** – využívají HW‑interrupty nebo VM‑funkce, neinvazivní, ale jen odhad (vzorkování)
- **událostní profily** – pro interpretované jazyky (JVM TI, .NET Profiling API, Python hotshot, Ruby profile.rb)

**Typické problémy**

- instrumentace může zkreslit chování, zvláště u vícevláknových aplikací
- příliš rychlé programy nemusí poskytnout dostatečný počet vzorků
- nasazení profileru v produkci může ovlivnit stabilitu nebo bezpečnost

**Základní výstupy**

- **profil** – souhrnná statistika volání (často „flat profile“)
- **trace** – sekvence událostí, užitečná pro vícevláknové aplikace, ale obtížně analyzovatelná při dlouhém běhu
- **paměťové statistiky** – alokace, GC, heap‑dumpy

**Manuální profilování**

- často stačí jednoduché měření (`clock()`, `std::chrono` v C/C++, `System.nanoTime()` v Javě)
- vhodné pro rychlé ověření podezření, ale musí být odstraněno z produkčních verzí

**Alokace paměti**

- sledování alokací pomocí JVM parametru `-Xaprof`
- po ukončení vypíše seznam objektů a jejich počty (neukazuje _kdy_ a _proč_)
- detailní zjištění, kdo alokuje paměť, vyžaduje instrumentaci (aspekty, bytecode manipulation)

**Změny bytecode**

- lze provádět za běhu (např. knihovna ObjectWeb ASM)
- vkládání hooků do classloaderu (`java.lang.instrument`)
- umožňuje sledovat konkrétní volání a měnit instrukce

**Sledování Garbage kolektoru**

- parametry: `-verbose:gc`, `-XX:+PrintGCDetails`, `-XX:+PrintGCTimeStamps`, `-XX:+PrintClassHistogramAfterFullGC`
- výstup ukazuje stav před a po GC, dobu trvání a velikosti haldy

**Analýza JIT kompilace**

- logování s `-XX:+UnlockDiagnosticVMOptions` a `-XX:+LogCompilation`
- další nástroje: `-XX:+TraceClassLoading`, `-XX:+PrintAssembly`, JITWatch (vizuální analýza)

**Přehled nástrojů**

| Nástroj                  | Popis                                                      |
| ------------------------ | ---------------------------------------------------------- |
| **JConsole**             | Sledování paměti, vláken, vzdálené JMX připojení           |
| **Java Mission Control** | Pokročilé monitorování paměti, GC, vláken a událostí v JVM |
| **VisualVM**             | Analýza heap dumpů, profilování vláken, volání metod       |
| **Flight Recorder**      | Záznam běhu (CPU, paměť, události) pro pozdější analýzu    |

**Urychlení Javy**

- primitivní typy jsou rychlejší než objekty
- vyhnout se tvorbě dočasných objektů v cyklech
- minimalizovat výjimky a synchronizaci; používat immutable objekty a concurrent kolekce
- frameworky (Hibernate, GSON…) mohou výrazně zpomalit kvůli reflexi

**Výkon softwaru**

- měření časových úseků je snadné, ale identifikace optimalizačních míst obtížná
- algoritmická složitost (O(N log N) vs. O(N) atd.) pomáhá odhadnout potenciál
- často je nutné kompromis mezi časem, pamětí a spolehlivostí

**Databázové optimalizace**

- **eager vs. lazy loading**: vyvážit počet dotazů a objem přenášených dat
- **cache**: nastavit velikost empiricky, sledovat hit/miss poměr
- **connection pooling**: předem vytvořit a dimenzovat pool, měřit čekání na připojení
- **složité dotazy**: SELECT místo JOIN, slučování tabulek při ORM
- **indexy**: urychlují vyhledávání, ale zpomalují vkládání; spravovat podle dotazů
- **timeouty**: zabránit vyčerpání zdrojů při neukončených spojení

**Paměť a GC**

- Minor GC (Eden) vs. Major GC (Stop‑the‑world).
- concurrent Mark‑Sweep snižuje pauzy
- správné nastavení velikostí Eden, Survivor a Tenured prostorů podle profilu aplikace
- sledování alokací, jsou časově náročné

**Memory bloat a leak**

- **bloat**: nadbytečná data, velké kolekce, zbytečné reference.
- **leak** v Javě často vzniká zapomenutými referencemi (např. posluchači, session)
- použití slabých referencí (`WeakReference`, `WeakHashMap`) pro cache a podobné struktury

**Souběh a synchronizace**

- synchronizace snižuje paralelismus
- preference immutable objektů – není třeba je synchronizovat
- použití jemnějších zámků (`ReentrantLock`, `ReadWriteLock`) a neblokující `tryLock()`
