# Symbolické vykonávání

**Symbolické vykonávání** (Symbolic execution)
- analýza programu zjišťující vztah mezi vstupy a cestami v programu
- specifický způsob interpretace programů pro testování

**Konkolické testování** (Concolic = Concrete + Symbolic)
- dynamické symbolické vykonávání
- současné provádění a sledování běhu programu a jeho symbolická analýza
- menší stavový prostor, využití informací z běhu

**Konkrétní vykonávání** (Concrete execution)
- spuštění programu s jednou sadou parametrů

### Implementace

- vstupy a proměnné nahrazeny symboly – nemají konkrétní hodnotu, jen **omezení (constraints)**, snažíme se najít všechny cesty programu
- při interpretaci programu udržím pro každou cestu **path condition** a záznam o omezeních symbolů
- řešení pomocí **backtrackingu** a automatických **SMT‑solverů** (Satisfiability Modulo Theories)
- SMT‑solver určuje, zda je matematická formule splnitelná – obecnější než SAT‑solver (NP‑těžký problém)
	- možné výsledky: zacyklení v nekonečné smyčce, vzdání se

### Constraint programming

- deklarativní programování: popis požadovaného řešení místo algoritmu
- zadávám **constraints**, engine (solver) hledá řešení, často s backtrackingem a prořezáváním stromu
- příklady: Prolog (predikátová logika), CLP(BNR) (celočíselná aritmetika) → SMT

### SMT – Satisfiability Modulo Theories

- prvořádová predikátová logika + teorie (čísla, pole, řetězce …)
- **rozhodnutelné**: celočíselná lineární aritmetika (NP‑úplná), pole (bez kvantifikátorů)
- **nerozhodnutelné**: celočíselná aritmetika s násobením, některé nelineární teorie

### Prohledávání stavového stromu

- DFS (zásobník) – snadno uvízne
- BFS (fronta) – málo inteligence
- stromová reprezentace – náhodné/heuristické prohledávání, preferování méně navštívených stavů

### Omezení

- **stavová exploze**: každé `if` dvojnásobí cesty, smyčky, paralelismus, rekurze
- SMT‑solvery selhávají u složitých nebo nerozhodnutelných konstrukcí (polymorfismus, ukazatele, heap, systémová volání, multithreading)

### Kdy použít?

- vhodné pro programy s nízkou cyklomatickou komplexitou, kritické řídící systémy
- účely: generování vstupů pokrývajících všechny cesty, hledání chyb, automatické testy, ověření kontraktů

### Dynamické symbolické vykonávání (Concolic)

- program běží s konkrétními vstupy a současně se sbírají symbolické podmínky
- po skončení cesty se vybere rozhodovací bod, vytvoří se nová path condition → nový vstup → opět spuštění
- nepotřebuje SMT‑solver, pokud je stav dosažitelný, dojdeme do něj

### DART přístup

1. známe rozhraní testovaného systému (vstupy, globální proměnné)
2. sledujeme skutečné provádění (dynamická analýza)
3. generujeme nové vstupy pomocí negace jedné z podmínek path condition
4. ověřujeme, že vstup vede k nové cestě a nevyvolává neočekávané chyby

### Nástroje

| Název                     | Jazyk/Platforma  | Typ                                       |
| ------------------------- | ---------------- | ----------------------------------------- |
| **JPF** (Java PathFinder) | Java             | Statické symbolické procházení            |
| **KLEE**                  | LLVM (C/C++)     | Dynamické symbolické                      |
| **CREST**                 | C                | Dynamické symbolické (instrumentace)      |
| **Angr**                  | Python (binárky) | Analýza na úrovni x86                     |
| **jCute**                 | Java             | Dynamické symbolické, detekce souběžnosti |
| **SymJS**, **SAGE**       | –                | (neveřejné/experimentální)                |

### Shrnutí

- symbolické a koncolické vykonávání umožňují systematické prozkoumání (teoreticky konečného) stavového prostoru, ale prakticky jsou omezeny stavovou explozí a omezeními solverů
- přesto dokážou odhalit chyby, které by lidský tester přehlédl, a jsou užitečné při generování testů, ověřování kontraktů a analýze kritických systémů