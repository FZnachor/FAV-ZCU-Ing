# Model checking

- existují požadavky na systém
	- nesmí dojít k dělení nulou, výjimce, přetečení
	- každá reakce musí být do x vteřin
	- nikdy nesmí dojít k deadlocku / jinému zaseknutí
	- nesmí dojít k souběhové chybě
- požadujeme jistotu, že při všech stavech nemůže některý případ nastat
- testy nepokryjí vše, symbolické vykonávání má omezení
- lze ověřit formálně na abstraktním modelu

### Formální postup

- vytvoření formálního, analyzovatelného modelu systému
	- CPU, řídící obvody, HW, komunikační protokoly, paralelní části SW
	- konečné automaty a grafová anaýza
- specifikace ověřované vlastnosti
	- časování, přístup k datům, médiu
	- formální logika – temporální, nestačí predikátová → SAT solver
- kontrola splnění vlastnosti v modelu
	- dokázání platnosti formule vůči modelu
	- ověření nakolik model a reálná implementace souhlasí
	- problémem může být stavová exploze

### Model výpočtu

- části modelu
	- konečné množiny stavů – potřeba je definovat, musí popisovat systém
	- podmnožiny počátečních a koncových stavů
	- přechodové funkce – kam se lze dostat z daného stavu
- popsatelné problémy
	- sekvenční a paralelní problémy (s vhodnou úrovní abstrakce)
	- číslicový HW, komunikační protokoly
- možné úpravy a vylepšení pro
	- nekonečné stavové prostory, spojité prostor, spojitý čas
	- pravděpodobnostní přechody a náhodné události

+ model je vždy abstrakcí (vždy nějak lže)
	+ abstrahujeme od moc složitých věcí (např. uživatelé nahrazení náhodou)
+ model nemusí být 100% dobře, aby byl užitečný

### Neformální popis

- orientovaný graf (LTS – Labeled Transition System)
	- vrcholy – stavy výpočtu (konfigurace systému v jednom okamžiku)
	- hrany – přechody mezi konfiguracemi
- často generovatelné ze zdrojového kódu programu

### Formální popis – Kripkeho struktura

- množina tvrzení o konfiguracích systému – $AP$
- nad ní Kripkeho struktura $M (S, S_0, R, L)$, kde
	- $S$ je konečná množina všech stavů systému
	- $S_0 \subset S$ je množina počátečních stavů
	- $R \subseteq S \times S$ je úplná přechodová relace
		- $\forall s \in S \, \exists \, s' \in S$ tak, že $(s, s') \in R$
		- neexistuje stok, ale nejde o silně souvislý graf
	- $L: S \rightarrow 2^{AP}$ je funkce označující každý stav sadou tvrzení, která v něm platí
- lze chápat jako speciální případ Mooreova automatu
	- vstupní abeceda s jediným symbolem
	- funkce L jako výstupní funkce
	- nemá koncové stavy, jen vstupní stavy
- cestu lze chápat jako nekonečné slovo

### Vlastnosti systému

- invarianty (neměnící se vlastnosti)
	- žádný stav systému není špatný (bez deadlocku)
- bezpečnost
	- nedojde k sekvenci, která narušuje požadované vlastnosti systému
- živost / funkčnost
	- systém provádí, co má (neobjevují se nežádoucí sekvence v cestě)

### Popis podmínek

Potřebné prvky
- primitivní vlastnosti stavů (sémantika) – vypnutý, zapnutý, čte, ...
- logické spojky – $\vee, \wedge, \rightarrow, \lnot$
- časové spojky – vyjádření sousledností a časů
	- v každém okamžiku platí, že nelze současně číst a zapisovat
	- pokud dorazí požadavek, bude do 10 časových jednotek vyřízen

#### Lineární čas (LTL)

- cesta jako sekvence stavů
- otázky v podobě
	- je nějaká vlastnost zaručena v každé cestě?
	- existuje cesta, která nezaručuje určitou vlastnost?
- nedeterminismus
	- vytvoření všech možných cest = vytvoření několik cest z počátečního stavu

#### Větvení (CTL)

- strom možných budoucností pro každý počáteční stav
- možnost složitějších otázek
	- existuje cesta, která by dodržela určitou vlastnost ve všech možných budoucích stavech?
- nedeterminismus
	- větvení při každém rozhodnutí
- CTL* = kombinace LTL a CTL vázaná na Kripkeho struktury

### LTL syntaxe

- máme množinu atomických tvrzení $Atom$ (podle modelu systému)
- lze sestavovat formule $\phi$
- běžné operátory $\vee, \wedge, \rightarrow, \lnot$
- nové operátory
	- $\textbf{X} \, \phi$ – ne**X**t $\phi$ – splněno, pokud $\phi$ bude platit v následujícím tavu
	- $\textbf{F} \, \phi$ – **F**inally $\phi$ – splněno, pokud $\phi$ bude platit někdy v budoucnosti (cestě)
	- $\textbf{G} \, \phi$ – **G**lobally $\phi$ – splněno, pokud $\phi$ bude platit ve všech následujících stavech
	- $\phi \, \textbf{U} \, \psi$ – $\phi$ **U**ntil $\psi$ – splněno, pokud $\phi$ bude platit nejméně do doby, než začne platit $\psi$, to musí být splněno v tomto nebo nějakém budoucím stavu
	- $\phi \, \textbf{R} \, \psi$ – $\phi$ **R**elease $\psi$ – $\phi$ musí platit až do bodu, kdy je splněno $\psi$, pokud nebude $\psi$ splněno nikdy, musí $\phi$ platit neustále

Neformální pohled na sémantiku
- formule vyhodnocovány v jednotlivých bodech cesty $\pi$ stavovým prostorem systému
	- atomické tvrzení $p$ je dodrženo, pokud je $p$ pravda ve stavu $i$
	- logické spojky mají běžný význam, LTL spojky popisují časové vlastnosti
- příklady
	- $\textbf{G} \, invariant$
		- invariant dodržen ve všech budoucích stavech
	- $\mathbf{G} \lnot (read \wedge write)$
		- v žádném budoucím stavu systém současně *nečte* a *nezapisuje*
	- $\mathbf{G}(request \rightarrow \mathbf{F} \, grant)$
		- v žádném budoucím stavu *odesílání požadavku* implikuje, že bude někdy později *potvrzen*
	- $\mathbf{G}(request \rightarrow (request \, \mathbf{U} \, grant))$
		- v každém budoucím stavu platí, že od *odeslání požadavku* je systém ve stavu *request* (čeká na potvrzení), dokud nedojde k získání potvrzení (*grant*)
	- $\textbf{G\,F} \, enabled$
		- pro každý budoucí stav existuje budoucnost, ve které je systém *dostupný*
	- $\mathbf{F\,G} \, enabled$
		- existuje budoucí stav, od kterého je systém už vždy dostupný

Jazykový přístup k věci – jazyk struktury
- přechodový systém $M = \langle S, S_0, \rightarrow, L \rangle$
	- množinu stavů $S$ lze prohlásit za abecedu $\sum$
	- každá nekonečná cesta $\pi$ je slovo z množiny $\sum^\omega$
	- množina všech cest z $M$ je jazyk $L(M)$ přijímaný strukturou $M$

Jazykový přístup k věci – jazyk LTL
- formule $\phi$ a množina stavů $S$
	- stejná atomická tvrzení jako u $M$
- jazyk $L(\phi) = \{ \pi \in S^\omega | \pi \models^0 \phi \}$
	- otázkou je, jak jej popsat – nelze převést na LTS
	- možné využít abstrakci zvláštním druhem automatu (Büchiho automat)
- Büchiho automat
	- nedeterministický automat
	- přijímá nebo odmítá nekonečně dlouhý vstup
	- podobný běžným automatům, ale bez vstupního stavu

### Nástroje

UPPAAL
- modely časového chování systému, simulace a model checking
- důkladně dokumentovaný, řada tutoriálů a ukázkových studií

NuSMV / nuXmv
- symbolický model checking
- umí simulovat BA, LTL a CTL – rozsáhlé stavové prostory

### Výhody a nevýhody

**Nevýhody**
- popisy v temporální logice pracné a těžko čitelné
- zaměřené na tok řízení programu, ne na data
- stavová exploze – model checking příliš neškáluje
- komplikace modelování
	- velké datové typy (string, double)
	- uživatelsky definované typy – třídy a struktury
	- ukazatele, generické chování referencí a alokace v heapu
	- přetížené metody, polymorfismus

**Výhody**
- použitelné na řadu malých problémů
- lze omezit jen na důležité věci
- potenciál pro plně automatické nástroje
- poskytuje protipříklady (cestu k selhání, užitečné pro debugging)
- není zatíženo biasy testerů
- formální matematický základ